services:
  {{ socket_proxy.service }}:
    image: "{{ socket_proxy.image }}"
    container_name: "{{ socket_proxy.service }}"
    restart: "unless-stopped"

    # Run as nobody (65534) + Host Docker GID
    user: "65534:{{ socket_proxy_gid }}"

    read_only: true

    deploy:
      resources:
        limits:
          memory: {{ socket_proxy.memory }}

    cap_drop:
      - ALL
    security_opt:
      - no-new-privileges

    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro

    command:
      - "-loglevel=info"
      - "-listenip=0.0.0.0"
      - "-allowfrom={{ socket_proxy.allow_from }}"
      - "-allowGET={{ socket_proxy.patterns['get'] }}"
      - "-allowPOST={{ socket_proxy.patterns['post'] }}"
      - "-allowHEAD={{ socket_proxy.patterns['head'] }}"
      - "-watchdoginterval={{ socket_proxy.config.watchdog_interval }}"
      - "-shutdowngracetime={{ socket_proxy.config.shutdown_grace }}"
{% if socket_proxy.config.stop_on_watchdog | bool %}
      - "-stoponwatchdog"
{% endif %}
{% if socket_proxy.config.allow_healthcheck | bool %}
      - "-allowhealthcheck"
{% endif %}

    networks:
      # Expose ONLY to the isolated internal network
      socket_proxy:
        aliases:
          - socket-proxy # DNS alias for other containers

    healthcheck:
      test: ["CMD", "./healthcheck"]
      interval: 30s
      timeout: 5s
      retries: 3

networks:
  socket_proxy:
    name: socket_proxy
    internal: true # STRICTLY ISOLATED
